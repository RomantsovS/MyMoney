#Область ПрограммныйИнтерфейс

Процедура УстановитьОриентациюЭкрана() Экспорт
	
	#Если МОбильноеПриложениеСервер Тогда
		
		МассивИнформации = ПолучитьИнформациюЭкрановКлиента();
		
		Если МассивИнформации[0].Ширина > МассивИнформации[0].Высота Тогда
			ПараметрыСеанса.ГоризонтальнаяОриентацияЭкрана = Истина;
		Иначе
			ПараметрыСеанса.ГоризонтальнаяОриентацияЭкрана = Ложь;
		КонецЕсли;
		
	#Иначе
		
		ПараметрыСеанса.ГоризонтальнаяОриентацияЭкрана = Истина;
		
	#КонецЕсли
	
КонецПроцедуры

Процедура УстановитьШрифт(Форма) Экспорт
	
	Шрифт = ЗначениеНастроекПовтИсп.ШрифтПриложения();
	
	Для Каждого Элемент Из Форма.Элементы Цикл
		
		Попытка
			Элемент.Шрифт = Шрифт;
		Исключение
			// у поля нет свойства Шрифт
		КонецПопытки;
		
		Попытка
			Элемент.ШрифтЗаголовка = Шрифт;
		Исключение
			// у поля нет свойства ШрифтЗаголовка
		КонецПопытки;
		
	КонецЦикла;
	
КонецПроцедуры

Функция ЗначениеИзСтрокиXML(СтрокаXML) Экспорт
	
	ЧтениеXML = Новый ЧтениеXML;
	ЧтениеXML.УстановитьСтроку(СтрокаXML);
	
	Возврат СериализаторXDTO.ПрочитатьXML(ЧтениеXML);
КонецФункции

// Возвращает структуру, содержащую значения реквизитов прочитанные из информационной базы
// по ссылке на Объект.
// 
//  Если доступа к одному из реквизитов нет, возникнет исключение прав доступа.
//  Если неОбходимо зачитать реквизит независимо от прав Текущего пользователя,
//  то следует использовать предварительный переход в привилегированный Режим.
// 
// Функция не предназначена Для получения значений реквизитов пустых ссылок.
//
// Параметры:
//  Ссылка    - ЛюбаяСсылка - Объект, значения реквизитов которого неОбходимо получить.
//
//  Реквизиты - Строка - имена реквизитов, перечисленные чеРез запятую, в формате
//              требований к свойствам структуры.
//              Например, "Код, Наименование, Родитель".
//            - Структура, ФиксированнаяСтруктура - в качестве ключа передается
//              псевдоним поля Для возвращаемой структуры с Результатом, а в качестве
//              значения (опционально) фактическое имя поля в таблице.
//              Если значение не определено, то имя поля берется из ключа.
//            - Массив, ФиксированныйМассив - имена реквизитов в формате требований
//              к свойствам структуры.
//
// Возвращаемое значение:
//  Структура - содержит имена (ключи) и значения затребованных реквизитов.
//              Если строка затребованных реквизитов пуста, то возвращается пустая структура.
//              Если в качестве Объекта передана пустая ссылка, то все реквизиты вернутся со значением Неопределено.
//
Функция ЗначенияРеквизитовОбъекта(Ссылка, Знач Реквизиты) Экспорт
	
	Если ТипЗнч(Реквизиты) = Тип("Строка") Тогда
		Если ПустаяСтрока(Реквизиты) Тогда
			Возврат Новый Структура;
		КонецЕсли;
		Реквизиты = СтрРазделить(Реквизиты, ",", Ложь);
	КонецЕсли;
	
	СтруктураРеквизитов = Новый Структура;
	Если ТипЗнч(Реквизиты) = Тип("Структура") Или ТипЗнч(Реквизиты) = Тип("ФиксированнаяСтруктура") Тогда
		СтруктураРеквизитов = Реквизиты;
	ИначеЕсли ТипЗнч(Реквизиты) = Тип("Массив") Или ТипЗнч(Реквизиты) = Тип("ФиксированныйМассив") Тогда
		Для Каждого Реквизит Из Реквизиты Цикл
			СтруктураРеквизитов.Вставить(СтрЗаменить(Реквизит, ".", ""), Реквизит);
		КонецЦикла;
	Иначе
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru = 'Неверный тип второго параметра Реквизиты: %1'"), Строка(ТипЗнч(Реквизиты)));
	КонецЕсли;
	
	ТекстПолей = "";
	Для Каждого КлючИЗначение Из СтруктураРеквизитов Цикл
		ИмяПоля   = ?(ЗначениеЗаполнено(КлючИЗначение.Значение),
		СокрЛП(КлючИЗначение.Значение),
		СокрЛП(КлючИЗначение.Ключ));
		
		Псевдоним = СокрЛП(КлючИЗначение.Ключ);
		
		ТекстПолей  = ТекстПолей + ?(ПустаяСтрока(ТекстПолей), "", ",") + "
		|	" + ИмяПоля + " КАК " + Псевдоним;
	КонецЦикла;
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("Ссылка", Ссылка);
	Запрос.Текст =
	"ВЫБРАТЬ
	|" + ТекстПолей + "
	|ИЗ
	|	" + Ссылка.Метаданные().ПолноеИмя() + " КАК ПсевдонимЗаданнойТаблицы
	|ГДЕ
	|	ПсевдонимЗаданнойТаблицы.Ссылка = &Ссылка
	|";
	Выборка = Запрос.Выполнить().Выбрать();
	Выборка.Следующий();
	
	Результат = Новый Структура;
	Для Каждого КлючИЗначение Из СтруктураРеквизитов Цикл
		Результат.Вставить(КлючИЗначение.Ключ);
	КонецЦикла;
	ЗаполнитьЗначенияСвойств(Результат, Выборка);
	
	Возврат Результат;
	
КонецФункции

// Возвращает значение реквизита, прочитанного из информационной базы по ссылке на Объект.
// 
//  Если доступа к реквизиту нет, возникнет исключение прав доступа.
//  Если неОбходимо зачитать реквизит независимо от прав Текущего пользователя,
//  то следует использовать предварительный переход в привилегированный Режим.
//
// Функция не предназначена Для получения значений реквизитов пустых ссылок.
// 
// Параметры:
//  Ссылка       - ссылка на Объект, - элемент справочника, документ, ...
//  ИмяРеквизита - Строка, например, "Код".
// 
// Возвращаемое значение:
//  Произвольный    - зависит от типа значения прочитанного реквизита.
// 
Функция ЗначениеРеквизитаОбъекта(Ссылка, ИмяРеквизита) Экспорт
	
	Результат = ЗначенияРеквизитовОбъекта(Ссылка, ИмяРеквизита);
	Возврат Результат[СтрЗаменить(ИмяРеквизита, ".", "")];
	
КонецФункции

Процедура ПровестиВсеДокументы(Знач ПараметрыВыгрузки, АдресХранилища = Неопределено) Экспорт 
	Выборка = Документы.ВводОстатков.Выбрать();
	
	ОбщегоНазначенияКлиентСервер.СообщитьПользователю(НСтр("ru = '{СтандартныеПодсистемы.ДлительныеОперации}0%'"));
	
	Пока Выборка.Следующий() Цикл
		ДокО = Выборка.ПолучитьОбъект();
		ДокО.Записать(РежимЗаписиДокумента.Проведение);
	КонецЦикла;
	
	Запрос = Новый Запрос("ВЫБРАТЬ
	|	Операция.Ссылка
	|ИЗ
	|	Документ.Операция КАК Операция
	|
	|УПОРЯДОЧИТЬ ПО
	|	Операция.Дата");
	
	Выборка = Запрос.Выполнить().Выбрать();
	
	ВсегоДок = Выборка.Количество();
	
	Индекс = 1;
	
	Пока Выборка.Следующий() Цикл
		ДокО = Выборка.Ссылка.ПолучитьОбъект();
		
		Попытка
			ДокО.Записать(РежимЗаписиДокумента.Проведение);
		Исключение
			ОбщегоНазначенияКлиентСервер.СообщитьПользователю(СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru = 'Возникла ошибка при проведении %1: %2'"),
			ДокО, ОписаниеОшибки()));
		КонецПопытки;
		
		ОбщегоНазначенияКлиентСервер.СообщитьПользователю(СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
		НСтр("ru = '{СтандартныеПодсистемы.ДлительныеОперации}%1%
		|Последний проведенный Объект: %2'"), Окр(Индекс / ВсегоДок * 100, 2), ДокО));
		
		Индекс = Индекс + 1;
	КонецЦикла;
КонецПроцедуры

// Сравнить две строки версий.
//
// Параметры
//  СтрокаВерсии1  – Строка – номер версии в формате РР.{П|ПП}.ЗЗ.СС
//  СтрокаВерсии2  – Строка – второй сравниваемый номер версии
//
// Возвращаемое значение:
//   Число   – больше 0, Если СтрокаВерсии1 > СтрокаВерсии2; 0, Если версии равны.
//
Функция СравнитьВерсии(Знач СтрокаВерсии1, Знач СтрокаВерсии2) Экспорт
	
	Строка1 = ?(ПустаяСтрока(СтрокаВерсии1), "0.0.0", СтрокаВерсии1);
	Строка2 = ?(ПустаяСтрока(СтрокаВерсии2), "0.0.0", СтрокаВерсии2);
	Версия1 = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(Строка1, ".");
	Если Версия1.Количество() <> 3 Тогда
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
		НСтр("ru = 'Неправильный формат строки версии: %1'"), СтрокаВерсии1);
	КонецЕсли;
	Версия2 = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(Строка2, ".");
	Если Версия2.Количество() <> 3 Тогда
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
		НСтр("ru = 'Неправильный формат строки версии: %1'"), СтрокаВерсии2);
	КонецЕсли;
	
	Результат = 0;
	Для Разряд = 0 По 2 Цикл
		Результат = Число(Версия1[Разряд]) - Число(Версия2[Разряд]);
		Если Результат <> 0 Тогда
			Возврат Результат;
		КонецЕсли;
	КонецЦикла;
	Возврат Результат;
	
КонецФункции

Функция ПриНачалеРаботыСистемыПроверитьНеОбходимостьЗагрузкиКурсов() Экспорт 
	ЗагрузкаКурсов = Обработки.ЗагрузкаКурсовВалют.Создать();
	
	Возврат ЗагрузкаКурсов.ПриНачалеРаботыСистемыПроверитьНеОбходимостьЗагрузкиКурсов();
КонецФункции

Процедура УдалитьВсеДанныеНаСервере(Знач ПараметрыВыгрузки, АдресХранилища = Неопределено) Экспорт 
	
	ОбщегоНазначенияКлиентСервер.СообщитьПользователю(НСтр("ru = '{СтандартныеПодсистемы.ДлительныеОперации}0%'"));
	
	Запрос = Новый Запрос("ВЫБРАТЬ РАЗЛИЧНЫЕ
	|	КурсыВалют.Валюта
	|ИЗ
	|	РегистрСведений.КурсыВалют КАК КурсыВалют");
	Рез = Запрос.Выполнить().Выбрать();
	
	Пока Рез.Следующий() Цикл
		Набор = РегистрыСведений.КурсыВалют.СоздатьНаборЗаписей();
		Набор.Отбор.Валюта.установить(Рез.Валюта);
		Набор.Прочитать();
		Набор.Очистить();
		Набор.Записать();
	КонецЦикла;
	
	ОбщегоНазначенияКлиентСервер.СообщитьПользователю(НСтр("ru = '{СтандартныеПодсистемы.ДлительныеОперации}3%'"));
	
	Запрос = Новый Запрос("ВЫБРАТЬ РАЗЛИЧНЫЕ
	|	ОбщиеНастройки.КлючНастроек
	|ИЗ
	|	РегистрСведений.ОбщиеНастройки КАК ОбщиеНастройки");
	Рез = Запрос.Выполнить().Выбрать();
	
	Пока Рез.Следующий() Цикл
		Набор = РегистрыСведений.ОбщиеНастройки.СоздатьНаборЗаписей();
		Набор.Отбор.КлючНастроек.установить(Рез.КлючНастроек);
		Набор.Прочитать();
		Набор.Очистить();
		Набор.Записать();
	КонецЦикла;
	
	ОбщегоНазначенияКлиентСервер.СообщитьПользователю(НСтр("ru = '{СтандартныеПодсистемы.ДлительныеОперации}4%'"));
	
	Для Каждого СтрМета Из Метаданные.Константы Цикл
		Константы[СтрМета.Имя].Установить(Неопределено);
	КонецЦикла;
	
	ОбщегоНазначенияКлиентСервер.СообщитьПользователю(НСтр("ru = '{СтандартныеПодсистемы.ДлительныеОперации}5%'"));
	
	Выборка = Документы.ВводОстатков.Выбрать();
	
	Пока Выборка.Следующий() Цикл
		Об = Выборка.ПолучитьОбъект();
		Об.Удалить();
	КонецЦикла;
	
	Запрос = Новый Запрос("ВЫБРАТЬ
	|	Операция.Ссылка
	|ИЗ
	|	Документ.Операция КАК Операция");
	Выборка = Запрос.Выполнить().Выбрать();
	
	индекс = 0;
	
	Пока Выборка.Следующий() Цикл
		Об = Выборка.ссылка.ПолучитьОбъект();
		Об.Удалить();
		
		ОбщегоНазначенияКлиентСервер.СообщитьПользователю(СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru = '{СтандартныеПодсистемы.ДлительныеОперации}%1%'"),
		5 + Окр(85 * индекс / Выборка.количество())));
		
		индекс = индекс + 1;
	КонецЦикла;
	
	Выборка = Справочники.Валюты.Выбрать();
	
	Пока Выборка.Следующий() Цикл
		Об = Выборка.ПолучитьОбъект();
		Об.Удалить();
	КонецЦикла;
	
	ОбщегоНазначенияКлиентСервер.СообщитьПользователю(НСтр("ru = '{СтандартныеПодсистемы.ДлительныеОперации}91%'"));
	
	Выборка = Справочники.Кошельки.Выбрать();
	
	Пока Выборка.Следующий() Цикл
		Об = Выборка.ПолучитьОбъект();
		Об.Удалить();
	КонецЦикла;
	
	ОбщегоНазначенияКлиентСервер.СообщитьПользователю(НСтр("ru = '{СтандартныеПодсистемы.ДлительныеОперации}92%'"));
	
	Выборка = Справочники.Статьи.Выбрать();
	
	Пока Выборка.Следующий() Цикл
		попытка
			Об = Выборка.ПолучитьОбъект();
			Об.Удалить();
		Исключение
			ОбщегоНазначенияКлиентСервер.СообщитьПользователю(ОписаниеОшибки());
		КонецПопытки;
	КонецЦикла;
	
	ОбщегоНазначенияКлиентСервер.СообщитьПользователю(НСтр("ru = '{СтандартныеПодсистемы.ДлительныеОперации}93%'"));
	
	Выборка = Справочники.ФизЛица.Выбрать();
	
	Пока Выборка.Следующий() Цикл
		Об = Выборка.ПолучитьОбъект();
		Об.Удалить();
	КонецЦикла;
	
	ОбщегоНазначенияКлиентСервер.СообщитьПользователю(НСтр("ru = '{СтандартныеПодсистемы.ДлительныеОперации}94%'"));
	
	Выборка = Справочники.КлючНастроек.Выбрать();
	
	Пока Выборка.Следующий() Цикл
		Об = Выборка.ПолучитьОбъект();
		Об.Удалить();
	КонецЦикла;
	
	ОбщегоНазначенияКлиентСервер.СообщитьПользователю(НСтр("ru = '{СтандартныеПодсистемы.ДлительныеОперации}95%'"));
	
	Выборка = Справочники.Метки.Выбрать();
	
	Пока Выборка.Следующий() Цикл
		Об = Выборка.ПолучитьОбъект();
		Об.Удалить();
	КонецЦикла;
	
	ОбщегоНазначенияКлиентСервер.СообщитьПользователю(НСтр("ru = '{СтандартныеПодсистемы.ДлительныеОперации}98%'"));
	
	Выборка = Справочники.ШаблоныЧтенияСМС.Выбрать();
	
	Пока Выборка.Следующий() Цикл
		Об = Выборка.ПолучитьОбъект();
		Об.Удалить();
	КонецЦикла;
	
	ОбщегоНазначенияКлиентСервер.СообщитьПользователю(НСтр("ru = '{СтандартныеПодсистемы.ДлительныеОперации}100%'"));
	
КонецПроцедуры

Функция ПолучитьТекстПериоды(Периодичность, Период) Экспорт 
	
	ПериодыТекст = "ВЫБРАТЬ
	|	0 КАК Р
	|ПОМЕСТИТЬ Разряды
	|
	|ОБЪЕДИНИТЬ
	|
	|ВЫБРАТЬ
	|	1
	|
	|ОБЪЕДИНИТЬ
	|
	|ВЫБРАТЬ
	|	2
	|
	|ОБЪЕДИНИТЬ
	|
	|ВЫБРАТЬ
	|	3
	|
	|ОБЪЕДИНИТЬ
	|
	|ВЫБРАТЬ
	|	4
	|
	|ОБЪЕДИНИТЬ
	|
	|ВЫБРАТЬ
	|	5
	|
	|ОБЪЕДИНИТЬ
	|
	|ВЫБРАТЬ
	|	6
	|
	|ОБЪЕДИНИТЬ
	|
	|ВЫБРАТЬ
	|	7
	|
	|ОБЪЕДИНИТЬ
	|
	|ВЫБРАТЬ
	|	8
	|
	|ОБЪЕДИНИТЬ
	|
	|ВЫБРАТЬ
	|	9
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ РАЗРЕШЕННЫЕ
	|	ДОБАВИТЬКДАТЕ(НАЧАЛОПЕРИОДА(&НачалоПериода, ДЕНЬ), ДЕНЬ, Единицы.Р + Десятки.Р * 10 + Сотни.Р * 100) КАК Период
	|ПОМЕСТИТЬ Вт_Периоды
	|ИЗ
	|	Разряды КАК Единицы,
	|	Разряды КАК Сотни,
	|	Разряды КАК Десятки
	|ГДЕ
	|	ДОБАВИТЬКДАТЕ(НАЧАЛОПЕРИОДА(&НачалоПериода, ДЕНЬ), ДЕНЬ, Единицы.Р + Десятки.Р * 10 + Сотни.Р * 100) <= &КонецПериода";
	
	Возврат ПериодыТекст;
КонецФункции

процедура РасчетШириныКолонок(ТабличныйДокумент, процентШирины = Неопределено, масштаб = 100) Экспорт 
	
	
	Перем МаксимальноеКоличествоСтрок, МаксимальнаяШиринаКолонки;
	
	
	Перем КонечнаяСтрока, НачальнаяСтрока, ТекущаяКолонка, ТекущаяСтрока, НачалоДанных;
	
	
	Перем ОбластьШапки, ОбластьПодвала;
	
	
	Перем ШиринаКолонки, ТекстЯчейки, НомерСтрокиТекста;
	
	
	Перем КоличествоУровнейГруппировокСтрок, Отступ;
	
	
	Перем ШириныКолонок;
	
	
	
	
	
	// Максимальное количество строк отчета, которые будут использованы Для расчета ширин колонок
	
	
	
	
	
	МаксимальноеКоличествоСтрок = 150;
	
	
	// Ограничение максимальной ширины колонки
	
	
	
	
	
	МаксимальнаяШиринаКолонки = 50;
	
	
	// Массив, в который будут помещаться ширины колонок
	
	
	
	
	
	ШириныКолонок = Новый Массив;
	
	
	// Получим количество уровней группировок в отчете Для учета автоматического отступа
	
	
	
	
	
	КоличествоУровнейГруппировокСтрок = ТабличныйДокумент.КоличествоУровнейГруппировокСтрок();
	
	
	
	
	
	// Инициализируем начальные строки
	
	
	
	
	
	НачальнаяСтрока = 0;
	
	
	НачалоДанных = 1;
	
	
	
	
	
	// Найдем в Результирующем документе Область шапки таблицы
	
	
	
	
	
	ОбластьШапки = ТабличныйДокумент.Области.Найти("ШапкаТаблицы");
	
	
	Если ТипЗнч(ОбластьШапки) = Тип("ОбластьЯчеекТабличногоДокумента") Тогда
		
		
		
		
		
		// Из шапки таблицы получим начальную строку с которой будем рассчитывать ширины
		
		
		НачальнаяСтрока = ОбластьШапки.Верх;
		
		
		НачалоДанных = ОбластьШапки.Низ + 1;
		
		
	Иначе
		
		
		
		
		
		// Если Область шапки таблицы не найдена, найдем Область шапки строк
		
		
		ОбластьШапки = ТабличныйДокумент.Области.Найти("ШапкаСтрок");
		
		
		Если ТипЗнч(ОбластьШапки) = Тип("ОбластьЯчеекТабличногоДокумента") Тогда
			
			
			
			
			
			// Из шапки таблицы получим начальную строку с которой будем рассчитывать ширины
			
			
			НачальнаяСтрока = ОбластьШапки.Верх;
			
			
			НачалоДанных = ОбластьШапки.Низ + 1;
			
			
			
			
			
		КонецЕсли;
		
		
	КонецЕсли;
	
	
	
	
	
	// Получим Область подвала отчета и вычислим конечную строку расчета
	
	
	
	
	
	ОбластьПодвала = ТабличныйДокумент.Области.Найти("Подвал");
	
	
	Если ТипЗнч(ОбластьПодвала) = Тип("ОбластьЯчеекТабличногоДокумента") Тогда
		
		
		// Область подвала найдена
		
		
		КонечнаяСтрока = ОбластьПодвала.Верх - 1;
		
		
		Если КонечнаяСтрока - НачальнаяСтрока > МаксимальноеКоличествоСтрок Тогда
			
			
			КонечнаяСтрока = НачальнаяСтрока + МаксимальноеКоличествоСтрок;
			
			
		КонецЕсли;
		
		
	Иначе 
		
		
		// Область подвала не найдена
		
		
		КонечнаяСтрока = НачальнаяСтрока + МаксимальноеКоличествоСтрок;
		
		
	КонецЕсли;
	
	
	
	
	
	// Ограничим конечную строку
	
	
	КонечнаяСтрока = Мин(КонечнаяСтрока, ТабличныйДокумент.ВысотаТаблицы);
	
	
	// Переберем все колонки отчета
	
	
	Для ТекущаяКолонка = 1 По ТабличныйДокумент.ШиринаТаблицы Цикл
		
		
		АвтоОтступ = 0;
		
		
		// Переберем строки, которые будут использованы Для расчета ширин колонок
		
		
		Для ТекущаяСтрока = НачальнаяСтрока По КонечнаяСтрока Цикл
			
			
			ШиринаКолонки = 0;
			
			
			// Получим Область Текущей ячейки
			
			
			ОбластьЯчейки = ТабличныйДокумент.Область(ТекущаяСтрока, ТекущаяКолонка);
			
			
			Если ОбластьЯчейки.Лево <> ТекущаяКолонка Или ОбластьЯчейки.Верх <> ТекущаяСтрока Тогда
				
				
				// Данная ячейка принадлежит Объединенным ячейкам и не является начальной ячейкой
				
				
				Продолжить;
				
				
			КонецЕсли;
			
			
			Если КоличествоУровнейГруппировокСтрок > 0 И ТекущаяСтрока = НачалоДанных Тогда
				
				
				// Для первой строки с данными получим значение автоотступа
				
				
				АвтоОтступ = ОбластьЯчейки.АвтоОтступ;
				
				
			КонецЕсли;
			
			АвтоОтступ = ОбластьЯчейки.АвтоОтступ;
			
			
			// Получим Текст ячейки
			
			
			ТекстЯчейки = ОбластьЯчейки.Текст;
			
			
			// Для каждой строки из Текста ячейки рассчитаем количество символов в строке
			
			
			Для НомерСтрокиТекста = 1 По СтрЧислоСтрок(ТекстЯчейки) Цикл
				
				
				ШиринаТекстаЯчейки = СтрДлина(СтрПолучитьСтроку(ТекстЯчейки, НомерСтрокиТекста));
				
				Если ОбластьЯчейки.формат = "ЧДЦ=2; ЧН=" Тогда 
					ШиринаТекстаЯчейки = ШиринаТекстаЯчейки * 0.75 * масштаб / 100;
				Иначе
					ШиринаТекстаЯчейки = ШиринаТекстаЯчейки * масштаб / 100;
				КонецЕсли;
				
				// Если используется автоотступ, то прибавим к ширине ячейки его величину
				
				
				Если АвтоОтступ <> Неопределено И АвтоОтступ > 0 Тогда
					
					
					ШиринаТекстаЯчейки = ШиринаТекстаЯчейки + КоличествоУровнейГруппировокСтрок * АвтоОтступ;
					
					
				КонецЕсли;
				
				
				ШиринаКолонки = Макс(ШиринаКолонки, ШиринаТекстаЯчейки);
				
				
			КонецЦикла;
			
			
			
			
			
			Если ШиринаКолонки > МаксимальнаяШиринаКолонки Тогда
				
				
				// Ограничим ширину колонки
				
				
				ШиринаКолонки = МаксимальнаяШиринаКолонки;
				
				
			КонецЕсли;
			
			
			Если ШиринаКолонки <> 0 Тогда
				
				
				// Ширина колонки рассчитана
				
				
				// Определим, сколько ячеек по ширине используется в Области Для Текущей ячейки
				
				
				КоличествоКолонок = ОбластьЯчейки.Право - ОбластьЯчейки.Лево;
				
				
				// Переберем все ячейки, расположенные в Области
				
				
				Для НомерКолонки = 0 По КоличествоКолонок Цикл
					
					
					Если ШириныКолонок.ВГраница() > ТекущаяКолонка - 1 + НомерКолонки Тогда
						
						
						// В массиве ширин колонок уже был элемент Для Текущей колонки
						
						
						Если ШириныКолонок[ТекущаяКолонка - 1 + НомерКолонки] = Неопределено Тогда
							
							
							// Значение ширины колонки еще не было установлено
							
							
							ШириныКолонок[ТекущаяКолонка - 1 + НомерКолонки] = ШиринаКолонки / (КоличествоКолонок + 1);
							
							
						Иначе
							
							
							// Значение ширины колонки уже было установлено
							
							
							// Вычислим максимум ширины колонки
							
							
							ШириныКолонок[ТекущаяКолонка - 1 + НомерКолонки] = 
							
							
							Макс(ШириныКолонок[ТекущаяКолонка - 1 + НомерКолонки], ШиринаКолонки / (КоличествоКолонок + 1));
							
							
						КонецЕсли;
						
						
					Иначе
						
						
						// В массиве ширин колонок еще не было элемента Для данной колонки
						
						
						// ДОбавим элемент в массив ширин колонок
						
						
						ШириныКолонок.Вставить(ТекущаяКолонка - 1 + НомерКолонки, ШиринаКолонки / (КоличествоКолонок + 1));
						
						
					КонецЕсли;
					
					
				КонецЦикла;
				
				
			КонецЕсли;
			
			
		КонецЦикла; // Конец Цикла перебора строк
		
		
	КонецЦикла; // Конец Цикла перебора колонок
	
	
	
	
	
	// Переберем все элементы в массиве вычисленных ширин колонок
	
	
	Для ТекущаяКолонка = 0 По ШириныКолонок.ВГраница() Цикл
		
		
		Если ШириныКолонок[ТекущаяКолонка] <> Неопределено Тогда
			
			
			// Ширина колонок установлена
			
			
			// Установим ширину Области ячеек
			
			ТекШиринаКолонки = ШириныКолонок[ТекущаяКолонка] + 1;
			
			Если ТипЗнч(процентШирины) = тип("Массив") Тогда 
				Если процентШирины.количество() > ТекущаяКолонка Тогда 
					ТекПроцентШирины = процентШирины[ТекущаяКолонка];
				Иначе
					ТекПроцентШирины = 100;
				КонецЕсли;
			ИначеЕсли ТипЗнч(процентШирины) = тип("Число") Тогда 
				ТекПроцентШирины = процентШирины;
			Иначе
				ТекПроцентШирины = 100;
			КонецЕсли;
			
			ТекШиринаКолонки = ТекШиринаКолонки / 100 * ?(ТекПроцентШирины = 0, 100, ТекПроцентШирины);
			
			ТекОбласть = ТабличныйДокумент.Область(, ТекущаяКолонка + 1, НачалоДанных, ТекущаяКолонка + 1);
			ТекОбласть.ШиринаКолонки = ТекШиринаКолонки;
			ТекОбласть.Шрифт = Новый Шрифт(ТекОбласть.Шрифт, , , , , , , масштаб);	
			
		КонецЕсли;
		
		
	КонецЦикла;
	
	
КонецПроцедуры

Процедура РасчетВысотыКолонок(ТабличныйДокумент, масштаб = 100) Экспорт 
	НачальнаяСтрока = 1;
	КонечнаяСтрока = ТабличныйДокумент.ВысотаТаблицы;
	
	Для номерСтроки = НачальнаяСтрока по КонечнаяСтрока Цикл
		ТекОбласть = ТабличныйДокумент.Область(номерСтроки, , номерСтроки,);
		ТекОбласть.ВысотаСтроки = ТекОбласть.ВысотаСтроки * масштаб / 100;
	КонецЦикла;
КонецПроцедуры

Функция ЕстьРеквизитОбъекта(Объект, ИмяРеквизита) Экспорт
	
	КлючУникальности   = Новый УникальныйИдентификатор;
	СтруктураРеквизита = Новый Структура(ИмяРеквизита, КлючУникальности);
	
	ЗаполнитьЗначенияСвойств(СтруктураРеквизита, Объект);
	
	Возврат СтруктураРеквизита[ИмяРеквизита] <> КлючУникальности;
	
КонецФункции

Функция ФиксированныеДанные(Данные, ВызыватьИсключение = Истина) Экспорт
	
	Если ТипЗнч(Данные) = Тип("Массив") Тогда
		Массив = Новый Массив;
		
		Для каждого Значение Из Данные Цикл
			
			Если ТипЗнч(Значение) = Тип("Структура")
				ИЛИ ТипЗнч(Значение) = Тип("Соответствие")
				ИЛИ ТипЗнч(Значение) = Тип("Массив") Тогда
				
				Массив.ДОбавить(ФиксированныеДанные(Значение, ВызыватьИсключение));
			Иначе
				Если ВызыватьИсключение Тогда
					ПроверкаФиксированностиДанных(Значение, Истина);
				КонецЕсли;
				Массив.ДОбавить(Значение);
			КонецЕсли;
		КонецЦикла;
		
		Возврат Новый ФиксированныйМассив(Массив);
		
	ИначеЕсли ТипЗнч(Данные) = Тип("Структура")
		ИЛИ ТипЗнч(Данные) = Тип("Соответствие") Тогда
		
		Если ТипЗнч(Данные) = Тип("Структура") Тогда
			Коллекция = Новый Структура;
		Иначе
			Коллекция = Новый Соответствие;
		КонецЕсли;
		
		Для каждого КлючИЗначение Из Данные Цикл
			Значение = КлючИЗначение.Значение;
			
			Если ТипЗнч(Значение) = Тип("Структура")
				ИЛИ ТипЗнч(Значение) = Тип("Соответствие")
				ИЛИ ТипЗнч(Значение) = Тип("Массив") Тогда
				
				Коллекция.Вставить(
				КлючИЗначение.Ключ, ФиксированныеДанные(Значение, ВызыватьИсключение));
			Иначе
				Если ВызыватьИсключение Тогда
					ПроверкаФиксированностиДанных(Значение, Истина);
				КонецЕсли;
				Коллекция.Вставить(КлючИЗначение.Ключ, Значение);
			КонецЕсли;
		КонецЦикла;
		
		Если ТипЗнч(Данные) = Тип("Структура") Тогда
			Возврат Новый ФиксированнаяСтруктура(Коллекция);
		Иначе
			Возврат Новый ФиксированноеСоответствие(Коллекция);
		КонецЕсли;
		
	ИначеЕсли ВызыватьИсключение Тогда
		ПроверкаФиксированностиДанных(Данные);
	КонецЕсли;
	
	Возврат Данные;
	
КонецФункции

Процедура ПроверкаФиксированностиДанных(Данные, ДанныеВЗначенииФиксированныхТипов = Ложь)
	
	ТипДанных = ТипЗнч(Данные);
	
	Если ТипДанных = Тип("ХранилищеЗначения")
		ИЛИ ТипДанных = Тип("ФиксированныйМассив")
		ИЛИ ТипДанных = Тип("ФиксированнаяСтруктура")
		ИЛИ ТипДанных = Тип("ФиксированноеСоответствие") Тогда
		
		Возврат;
	КонецЕсли;
	
	Если ДанныеВЗначенииФиксированныхТипов Тогда
		
		Если ТипДанных = Тип("Булево")
			ИЛИ ТипДанных = Тип("Строка")
			ИЛИ ТипДанных = Тип("Число")
			ИЛИ ТипДанных = Тип("Дата")
			ИЛИ ТипДанных = Тип("Неопределено")
			ИЛИ ТипДанных = Тип("УникальныйИдентификатор")
			ИЛИ ТипДанных = Тип("Null")
			ИЛИ ТипДанных = Тип("Тип")
			ИЛИ ТипДанных = Тип("ХранилищеЗначения")
			ИЛИ ТипДанных = Тип("ОбщийМодуль")
			ИЛИ ТипДанных = Тип("ОбъектМетаданных")
			ИЛИ ТипДанных = Тип("ТипЗначенияXDTO")
			ИЛИ ТипДанных = Тип("ТипОбъектаXDTO")
			ИЛИ ЭтоСсылка(ТипДанных) Тогда
			
			Возврат;
		КонецЕсли;
	КонецЕсли;
	
	ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
	НСтр("ru = 'Ошибка в функции ФиксированныеДанные Общего модуля ОбщегоНазначения.
	|Данные типа ""%1"" не могут быть зафиксированы.'"),
	Строка(ТипДанных) );
	
КонецПроцедуры

Функция ЭтоСсылка(ПроверяемыйТип) Экспорт
	
	Возврат ПроверяемыйТип <> Тип("Неопределено") 
	И (Справочники.ТипВсеСсылки().СодержитТип(ПроверяемыйТип)
	ИЛИ Документы.ТипВсеСсылки().СодержитТип(ПроверяемыйТип)
	ИЛИ Перечисления.ТипВсеСсылки().СодержитТип(ПроверяемыйТип)
	ИЛИ ПланыОбмена.ТипВсеСсылки().СодержитТип(ПроверяемыйТип));
	
КонецФункции

// Определяет принадлежность объекта метаданных к общему типу "Документ".
//
// Параметры:
//  ОбъектМетаданных - ОбъектМетаданных - объект, для которого необходимо определить принадлежность к документам.
// 
// Возвращаемое значение:
//   Булево - Истина, если объект является документом.
//
Функция ЭтоДокумент(ОбъектМетаданных) Экспорт
	
	Возврат Метаданные.Документы.Содержит(ОбъектМетаданных);
	
КонецФункции

// Определяет принадлежность объекта метаданных к общему типу "Справочник".
//
// Параметры:
//  ОбъектМетаданных - ОбъектМетаданных - объект, для которого необходимо определить принадлежность к заданному типу.
// 
// Возвращаемое значение:
//   Булево - Истина, если объект является справочником.
//
Функция ЭтоСправочник(ОбъектМетаданных) Экспорт
	
	Возврат Метаданные.Справочники.Содержит(ОбъектМетаданных);
	
КонецФункции

// Определяет принадлежность объекта метаданных к общему типу "Перечисление".
//
// Параметры:
//  ОбъектМетаданных - ОбъектМетаданных - объект, для которого необходимо определить принадлежность к заданному типу.
// 
// Возвращаемое значение:
//   Булево - Истина, если объект является перечислением.
//
Функция ЭтоПеречисление(ОбъектМетаданных) Экспорт
	
	Возврат Метаданные.Перечисления.Содержит(ОбъектМетаданных);
	
КонецФункции

// Возвращает ссылку на общий модуль по имени.
//
// Параметры:
//  Имя          - Строка - имя общего модуля, например:
//                 "ОбщегоНазначения",
//                 "ОбщегоНазначенияКлиент".
//
// Возвращаемое значение:
//  ОбщийМодуль - общий модуль.
//
Функция ОбщийМодуль(Имя) Экспорт
	
	Если Метаданные.ОбщиеМодули.Найти(Имя) <> Неопределено Тогда
		Модуль = Вычислить(Имя); // ВычислитьВБезопасномРежиме не требуется, т.к. проверка надежная.
	ИначеЕсли СтрЧислоВхождений(Имя, ".") = 1 Тогда
		Возврат СерверныйМодульМенеджера(Имя);
	Иначе
		Модуль = Неопределено;
	КонецЕсли;
	
	Если ТипЗнч(Модуль) <> Тип("ОбщийМодуль") Тогда
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru = 'Общий модуль ""%1"" не найден.'"), Имя);
	КонецЕсли;
	
	Возврат Модуль;
	
КонецФункции

// Выполнить экспортную процедуру по имени с уровнем привилегий конфигурации.
// При включении профилей безопасности для вызова оператора Выполнить() используется
// переход в безопасный режим с профилем безопасности, используемом для информационной базы
// (если выше по стеку не был установлен другой безопасный режим).
//
// Параметры:
//  ИмяМетода  - Строка - имя экспортной процедуры в формате
//                       <имя объекта>.<имя процедуры>, где <имя объекта> - это
//                       общий модуль или модуль менеджера объекта.
//  Параметры  - Массив - параметры передаются в процедуру <ИмяЭкспортнойПроцедуры>
//                        в порядке расположения элементов массива.
// 
// Пример:
//  Параметры = Новый Массив();
//  Параметры.Добавить("1");
//  ОбщегоНазначения.ВыполнитьМетодКонфигурации("МойОбщийМодуль.МояПроцедура", Параметры);
//
Процедура ВыполнитьМетодКонфигурации(Знач ИмяМетода, Знач Параметры = Неопределено) Экспорт
	
	ПроверитьИмяПроцедурыКонфигурации(ИмяМетода);
	
	ПараметрыСтрока = "";
	Если Параметры <> Неопределено И Параметры.Количество() > 0 Тогда
		Для Индекс = 0 По Параметры.ВГраница() Цикл 
			ПараметрыСтрока = ПараметрыСтрока + "Параметры[" + Индекс + "],";
		КонецЦикла;
		ПараметрыСтрока = Сред(ПараметрыСтрока, 1, СтрДлина(ПараметрыСтрока) - 1);
	КонецЕсли;
	
	Выполнить ИмяМетода + "(" + ПараметрыСтрока + ")";
	
КонецПроцедуры

// Выполнить экспортную процедуру объекта встроенного языка по имени.
// При включении профилей безопасности для вызова оператора Выполнить() используется
// переход в безопасный режим с профилем безопасности, используемом для информационной базы
// (если выше по стеку не был установлен другой безопасный режим).
//
// Параметры:
//  Объект    - Произвольный - объект встроенного языка 1С:Предприятия, содержащий методы (например, ОбработкаОбъект).
//  ИмяМетода - Строка       - имя экспортной процедуры модуля объекта обработки.
//  Параметры - Массив       - параметры передаются в процедуру <ИмяПроцедуры>
//                             в порядке расположения элементов массива.
//
Процедура ВыполнитьМетодОбъекта(Знач Объект, Знач ИмяМетода, Знач Параметры = Неопределено) Экспорт
	
	// Проверка имени метода на корректность.
	Попытка
		Тест = Новый Структура(ИмяМетода, ИмяМетода);
	Исключение
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru='Некорректное значение параметра ИмяМетода (%1) в ОбщегоНазначения.ВыполнитьМетодОбъекта'"), ИмяМетода);
	КонецПопытки;
	
	ПараметрыСтрока = "";
	Если Параметры <> Неопределено И Параметры.Количество() > 0 Тогда
		Для Индекс = 0 По Параметры.ВГраница() Цикл 
			ПараметрыСтрока = ПараметрыСтрока + "Параметры[" + Индекс + "],";
		КонецЦикла;
		ПараметрыСтрока = Сред(ПараметрыСтрока, 1, СтрДлина(ПараметрыСтрока) - 1);
	КонецЕсли;
	
	Выполнить "Объект." + ИмяМетода + "(" + ПараметрыСтрока + ")";
	
КонецПроцедуры

// Возвращает серверный модуль менеджера по имени объекта.
Функция СерверныйМодульМенеджера(Имя)
	ОбъектНайден = Ложь;
	
	ЧастиИмени = СтрРазделить(Имя, ".");
	Если ЧастиИмени.Количество() = 2 Тогда
		
		ИмяВида = ВРег(ЧастиИмени[0]);
		ИмяОбъекта = ЧастиИмени[1];
		
		Если ИмяВида = ВРег("Константы") Тогда
			Если Метаданные.Константы.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег("РегистрыСведений") Тогда
			Если Метаданные.РегистрыСведений.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег("РегистрыНакопления") Тогда
			Если Метаданные.РегистрыНакопления.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег("РегистрыБухгалтерии") Тогда
			Если Метаданные.РегистрыБухгалтерии.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег("РегистрыРасчета") Тогда
			Если Метаданные.РегистрыРасчета.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег("Справочники") Тогда
			Если Метаданные.Справочники.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег("Документы") Тогда
			Если Метаданные.Документы.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег("Отчеты") Тогда
			Если Метаданные.Отчеты.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег("Обработки") Тогда
			Если Метаданные.Обработки.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег("БизнесПроцессы") Тогда
			Если Метаданные.БизнесПроцессы.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег("ЖурналыДокументов") Тогда
			Если Метаданные.ЖурналыДокументов.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег("Задачи") Тогда
			Если Метаданные.Задачи.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег("ПланыСчетов") Тогда
			Если Метаданные.ПланыСчетов.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег("ПланыОбмена") Тогда
			Если Метаданные.ПланыОбмена.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег("ПланыВидовХарактеристик") Тогда
			Если Метаданные.ПланыВидовХарактеристик.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		ИначеЕсли ИмяВида = ВРег("ПланыВидовРасчета") Тогда
			Если Метаданные.ПланыВидовРасчета.Найти(ИмяОбъекта) <> Неопределено Тогда
				ОбъектНайден = Истина;
			КонецЕсли;
		КонецЕсли;
		
	КонецЕсли;
	
	Если Не ОбъектНайден Тогда
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Объект метаданных ""%1"" не найден,
			|либо для него не поддерживается получение модуля менеджера.'"), Имя);
	КонецЕсли;
	
	Модуль = Вычислить(Имя); // ВычислитьВБезопасномРежиме не требуется, т.к. проверка надежная.
	
	Возврат Модуль;
КонецФункции

// Проверяет, что переданное имя ИмяПроцедуры является именем экспортной процедуры конфигурации.
// Может использоваться для проверки, что переданная строка не содержит произвольного алгоритма
// на встроенном языке 1С:Предприятия перед использованием его в операторах Выполнить и Вычислить
// при их использовании для динамического вызова методов код конфигурации.
//
// В случае если переданная строка не является именем процедуры конфигурации, генерируется исключение.
//
// Предназначена для вызова из см. процедуру ВыполнитьМетодКонфигурации.
//
// Параметры:
//   ИмяПроцедуры - Строка - проверяемое имя экспортной процедуры.
//
Процедура ПроверитьИмяПроцедурыКонфигурации(Знач ИмяПроцедуры)
	
	ЧастиИмени = СтрРазделить(ИмяПроцедуры, ".");
	Если ЧастиИмени.Количество() <> 2 И ЧастиИмени.Количество() <> 3 Тогда
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Неправильный формат параметра ИмяПроцедуры (передано значение: ""%1"") в ОбщегоНазначения.ВыполнитьМетодКонфигурации'"), ИмяПроцедуры);
	КонецЕсли;
	
	ИмяОбъекта = ЧастиИмени[0];
	Если ЧастиИмени.Количество() = 2 И Метаданные.ОбщиеМодули.Найти(ИмяОбъекта) = Неопределено Тогда
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Неправильный формат параметра ИмяПроцедуры (передано значение: ""%1"") в ОбщегоНазначения.ВыполнитьМетодКонфигурации:
				|Не найден общий модуль ""%2"".'"),
			ИмяПроцедуры,
			ИмяОбъекта);
	КонецЕсли;
	
	Если ЧастиИмени.Количество() = 3 Тогда
		ПолноеИмяОбъекта = ЧастиИмени[0] + "." + ЧастиИмени[1];
		Попытка
			Менеджер = МенеджерОбъектаПоИмени(ПолноеИмяОбъекта);
		Исключение
			Менеджер = Неопределено;
		КонецПопытки;
		Если Менеджер = Неопределено Тогда
			ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru = 'Неправильный формат параметра ИмяПроцедуры (передано значение: ""%1"") в ОбщегоНазначения.ВыполнитьМетодКонфигурации:
				           |Не найден менеджер объекта ""%2"".'"),
				ИмяПроцедуры,
				ПолноеИмяОбъекта);
		КонецЕсли;
	КонецЕсли;
	
	ИмяМетодаОбъекта = ЧастиИмени[ЧастиИмени.ВГраница()];
	ВременнаяСтруктура = Новый Структура;
	Попытка
		// Проверка того, что ИмяПроцедуры является допустимым идентификатором.
		// Например: МояПроцедура.
		ВременнаяСтруктура.Вставить(ИмяМетодаОбъекта);
	Исключение
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Неправильный формат параметра ИмяПроцедуры (передано значение: ""%1"") в ОбщегоНазначения.ВыполнитьМетодКонфигурации:
			           |Имя метода ""%2"" не соответствует требованиям образования имен процедур и функций.'"),
			ИмяПроцедуры, ИмяМетодаОбъекта);
	КонецПопытки;
	
КонецПроцедуры

// Возвращает менеджер объекта по имени.
// Ограничение: не обрабатываются точки маршрутов бизнес-процессов.
//
// Параметры:
//  Имя - Строка - имя например, "Справочник", "Справочники", "Справочник.Организации".
//
// Возвращаемое значение:
//  СправочникиМенеджер, СправочникМенеджер, ДокументыМенеджер, ДокументМенеджер, ...
// 
Функция МенеджерОбъектаПоИмени(Имя)
	Перем КлассОМ, ИмяОМ, Менеджер;
	
	ЧастиИмени = СтрРазделить(Имя, ".");
	
	Если ЧастиИмени.Количество() > 0 Тогда
		КлассОМ = ВРег(ЧастиИмени[0]);
	КонецЕсли;
	
	Если ЧастиИмени.Количество() > 1 Тогда
		ИмяОМ = ЧастиИмени[1];
	КонецЕсли;
	
	Если      КлассОМ = "ПЛАНОБМЕНА"
	 Или      КлассОМ = "ПЛАНЫОБМЕНА" Тогда
		Менеджер = ПланыОбмена;
		
	ИначеЕсли КлассОМ = "СПРАВОЧНИК"
	      Или КлассОМ = "СПРАВОЧНИКИ" Тогда
		Менеджер = Справочники;
		
	ИначеЕсли КлассОМ = "ДОКУМЕНТ"
	      Или КлассОМ = "ДОКУМЕНТЫ" Тогда
		Менеджер = Документы;
		
	ИначеЕсли КлассОМ = "ЖУРНАЛДОКУМЕНТОВ"
	      Или КлассОМ = "ЖУРНАЛЫДОКУМЕНТОВ" Тогда
		Менеджер = ЖурналыДокументов;
		
	ИначеЕсли КлассОМ = "ПЕРЕЧИСЛЕНИЕ"
	      Или КлассОМ = "ПЕРЕЧИСЛЕНИЯ" Тогда
		Менеджер = Перечисления;
		
	ИначеЕсли КлассОМ = "ОБЩИЙМОДУЛЬ"
	      Или КлассОМ = "ОБЩИЕМОДУЛИ" Тогда
		
		Возврат ОбщийМодуль(ИмяОМ);
		
	ИначеЕсли КлассОМ = "ОБРАБОТКА"
	      Или КлассОМ = "ОБРАБОТКИ" Тогда
		Менеджер = Обработки;
		
	ИначеЕсли КлассОМ = "РЕГИСТРСВЕДЕНИЙ"
	      Или КлассОМ = "РЕГИСТРЫСВЕДЕНИЙ" Тогда
		Менеджер = РегистрыСведений;
		
	ИначеЕсли КлассОМ = "РЕГИСТРНАКОПЛЕНИЯ"
	      Или КлассОМ = "РЕГИСТРЫНАКОПЛЕНИЯ" Тогда
		Менеджер = РегистрыНакопления;
		
	ИначеЕсли КлассОМ = "КОНСТАНТА"
	      Или КлассОМ = "КОНСТАНТЫ" Тогда
		Менеджер = Константы;
		
	ИначеЕсли КлассОМ = "ПОСЛЕДОВАТЕЛЬНОСТЬ"
	      Или КлассОМ = "ПОСЛЕДОВАТЕЛЬНОСТИ" Тогда
		Менеджер = Последовательности;
	КонецЕсли;
	
	Если Менеджер <> Неопределено Тогда
		Если ЗначениеЗаполнено(ИмяОМ) Тогда
			Попытка
				Возврат Менеджер[ИмяОМ];
			Исключение
				Менеджер = Неопределено;
			КонецПопытки;
		Иначе
			Возврат Менеджер;
		КонецЕсли;
	КонецЕсли;
	
	ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru = 'Не удалось получить менеджер для объекта ""%1""'"), Имя);
	
КонецФункции

#КонецОбласти